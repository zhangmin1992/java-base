com.my.java.suanfa.Array
                        /**
                         * 功能描述: 给定一个排序的整数数据，在区间low和end之内，求不连续的缺失的数组
                         * 比如[0,1,3,50,75] low=0,end=99
                         * 输出"2,4-49,51-74,76,99
                         */
                        queshiqujian

com.my.java.suanfa.DFS
                        /**
                         * 功能描述: 给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。
                         * <p>
                         * 例如，路线 routes[0] = [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... 这样的车站路线行驶。
                         * 现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。
                         * <p>
                         * 求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。
                         * <p>
                         *  
                         * <p>
                         * 示例 1：
                         * <p>
                         * 输入：routes = [[1,2,7],[3,6,7]], source = 1, target = 6
                         * 输出：2
                         * 解释：最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。
                         * 示例 2：
                         * <p>
                         * 输入：routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
                         * 输出：-1
                         */
                        .numBusesToDestination

                        /**
                         * 功能描述: 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。
                         * 每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，‘0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。
                         * 锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。
                         * 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。
                         * 字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。
                         * <p>
                         * 输入：deadends = ["0201","0101","0102","1212","2002"], target = "0202"
                         * 输出：6
                         * 解释：可能的移动序列为 "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202"。
                         * 注意 "0000" -> "0001" -> "0002" -> "0102" -> "0202" 这样的序列是不能解锁的，
                         * 因为当拨动到 "0102" 时这个锁就会被锁定。
                         * <p>
                         * 输入: deadends = ["8888"], target = "0009"
                         * 输出：1
                         * 解释：把最后一位反向旋转一次即可 "0000" -> "0009"。
                         * <p>
                         * 输入: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"
                         * 输出：-1
                         * 解释：无法旋转到目标数字且不被锁定。
                         */
                         openlock

com.my.java.suanfa.DP
                         /**
                          * 功能描述: calcStep
                          * 有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法
                          *
                          * minPathSum
                          * 给你一个数组，求从[0,0]位置到[n-1,m-1]的最短路径。
                          * 规定路径只能向右边或者向下边移动
                          * 数组如图所示：
                          * 1	3	5	9
                          * 8	2	3	4
                          * 5	0	6	1
                          * 8	8	4	1
                          *
                          *
                          * 给定两个字符串s1和s2，长度分别为m和n，要求找出它们最长的子序列，并返回其长度。如：
                          * s1 = “HelloWorld”
                          * s2 = “loop”
                          * 它们的最长公共子序列为“loo”，长度为3。
                          *
                          * caculMaxVaule
                          * 一个背包有一定的承重capacity，有n件物品，每件都有自己的价值，记录在数组v中，
                          * 也都有自己的重量，记录在数组w中，
                          * 每件物品只能选择要装入背包还是不装入背包，要求在不超过背包承重的前提下，选出物品的总价值最大。
                          *
                          *
                          * maxProfit
                          * 买卖股票的最佳时机
                          *
                          * 给定一个无序的整数数组，找到其中最长上升子序列的长度。
                          * lengthOfLIS
                          *
                          * minDistance
                          * 求两个字符串的最短编辑距离
                          *
                          * getMaxZiXuHe
                          * 给定一个整数数组 nums 找到一个具有最大和的连续子数组
                          */
                         .DPTest

                         /**
                          * 功能描述: 给定不同面额的硬币 coins 和一个总金额 amount。
                          * 编写一个函数来计算可以凑成总金额所需的最少的硬币个数。
                          * 如果没有任何一种硬币组合能组成总金额，返回 -1。
                          *
                          * 示例 1:
                          * 输入: coins = [1, 2, 5], amount = 11
                          * 输出: 3
                          * 解释: 11 = 5 + 5 + 1
                          *
                          * 示例 2:
                          * 输入: coins = [2], amount = 3
                          * 输出: -1
                          */
                         .DPTest2

                         /**
                          * 功能描述: <br>
                          *     在组合数学中，如果一个排列中所有元素都不在原先的位置上，那么这个排列就被称为错位排列。
                          *
                          * 给定一个从 1 到 n 升序排列的数组，你可以计算出总共有多少个不同的错位排列吗？
                          *
                          * 由于答案可能非常大，你只需要将答案对 109+7 取余输出即可。
                          *
                          * 样例:
                          * 输入: 3
                          * 输出: 2
                          * 解释: 原始的数组为 [1,2,3]。
                          * 两个错位排列的数组为 [2,3,1] 和 [3,1,2]。
                          *
                          * 注释:
                          * n 的范围是 [1, 106]。
                          */
                          findDerangement

                          /**
                           * 功能描述: 不同的子序列
                           * 给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。
                           *
                           * 字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）
                           *
                           * 题目数据保证答案符合 32 位带符号整数范围。
                           *
                           *  
                           *
                           * 示例 1：
                           * 输入：s = "rabbbit", t = "rabbit"
                           * 输出：3
                           * 解释：
                           * 如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
                           * rabbbit
                           * rabbbit
                           * rabbbit
                           */
                           numDistinct

com.my.java.suanfa.dui
                      构建最小堆
                      .MinHeap

com.my.java.suanfa.erweishuzu
                             /**
                              * 功能描述:计算岛屿数量
                              * 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
                              * <p>
                              * 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
                              * <p>
                              * 此外，你可以假设该网格的四条边均被水包围。
                              * <p>
                              * 示例 1：
                              * <p>
                              * 输入：grid = [
                              * ["1","1","1","1","0"],
                              * ["1","1","0","1","0"],
                              * ["1","1","0","0","0"],
                              * ["0","0","0","0","0"]
                              * ]
                              * 输出：1
                              * 示例 2：
                              * 输入：grid = [
                              * ["1","1","0","0","0"],
                              * ["1","1","0","0","0"],
                              * ["0","0","1","0","0"],
                              * ["0","0","0","1","1"]
                              * ]
                              * 输出：3
                              * <p>
                              * <p>
                              * 力扣第 1020 题「飞地的数量」，这题不让你求封闭岛屿的数量，而是求封闭岛屿的面积总和
                              * 有一个二维矩阵 grid ，每个位置要么是陆地（记号为 0 ）要么是水域（记号为 1 ）。
                              * 我们从一块陆地出发，每次可以往上下左右 4 个方向相邻区域走，能走到的所有陆地区域，我们将其称为一座「岛屿」。
                              * 如果一座岛屿 完全 由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。
                              * 请返回封闭岛屿的数目。
                              * <p>
                              * <p>
                              * 力扣第 694 题「不同的岛屿数量：还是输入一个二维矩阵，0表示海水，1表示陆地，求不同岛屿的数量
                              * 怎么判断是相同岛屿呢？
                              * 假设它们的遍历顺序是：
                              * 下，右，上，撤销上，撤销右，撤销下
                              * 如果我用分别用1, 2, 3, 4代表上下左右，用-1, -2, -3, -4代表上下左右的撤销，那么可以这样表示它们的遍历顺序：
                              * 2, 4, 1, -1, -4, -2
                              * 你看，这就相当于是岛屿序列化的结果，只要每次使用dfs遍历岛屿的时候生成这串数字进行比较，就可以计算到底有多少个不同的岛屿了。
                              * <p>
                              * <p>
                              * 在二维地图上， 0代表海洋， 1代表陆地，我们最多只能将一格 0 海洋变成 1变成陆地。
                              * 进行填海之后，地图上最大的岛屿面积是多少？（上、下、左、右四个方向相连的 1 可形成岛屿）
                              * 示例 1:
                              * 输入: [[1, 0], [0, 1]]
                              * 输出: 3
                              * 解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。
                              * 示例 2:
                              * 输入: [[1, 1], [1, 0]]
                              * 输出: 4
                              * 解释: 将一格0变成1，岛屿的面积扩大为 4。
                              * 示例 3:
                              * 输入: [[1, 1], [1, 1]]
                              * 输出: 4
                              * 解释: 没有0可以让我们变成1，面积依然为 4。
                              */
                             .daoyu

                             /**
                              * 功能描述: 给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。
                              * 上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。
                              *
                              * 示例:
                              *
                              * 给定 matrix = [
                              * [3, 0, 1, 4, 2],
                              * [5, 6, 3, 2, 1],
                              * [1, 2, 0, 1, 5],
                              * [4, 1, 0, 1, 7],
                              * [1, 0, 3, 0, 5]
                              * ]
                              *
                              * sumRegion(2, 1, 4, 3) -> 8
                              * sumRegion(1, 1, 2, 2) -> 11
                              * sumRegion(1, 2, 2, 4) -> 12
                              * 说明:
                              *
                              * 你可以假设矩阵不可变。
                              * 会多次调用 sumRegion 方法。
                              * 你可以假设 row1 ≤ row2 且 col1 ≤ col2。
                              */
                             sumRegion

com.my.java.suanfa.huadongchuangkou
                                    /**
                                     * minWindow
                                     * 功能描述: 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。
                                     * 如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
                                     * 示例：
                                     * 输入：s = "ADOBECODEBANC", t = "ABC"
                                     * 输出："BANC"
                                     */
                                    .TestString
                                    /**
                                        equalSubstring
                                     * 给你两个长度相同的字符串，s 和 t。
                                     * 将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。
                                     * 用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。
                                     * 如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大子串
                                     */
                                     TestString2